# 整洁架构（Clean Architecture）在本后台前端的落地策略

本项目为 Vue 3 + TypeScript + Vite 的后台前端。整洁架构的目标是：让“业务规则（Domain / Use Case）”稳定可复用，让“框架与外部世界（Vue / Router / HTTP / Storage）”可替换、可测试、可演进。

## 1. 目标与边界

**目标**
- 业务逻辑与 UI/框架解耦，支持快速迭代与重构。
- API 变动影响面可控（集中在 Infrastructure 与 DTO 映射）。
- 单元测试聚焦 Domain 与 Use Case，不依赖浏览器与网络。
- 支持“按业务模块”扩展（Auth、用户、角色、权限、内容等）。

**非目标**
- 不追求“一开始就 100% 抽象完美”；以可落地、可维护为先。
- 不引入重型 IoC 容器；优先使用轻量工厂/组合根（Composition Root）。

## 2. 分层与依赖规则

核心规则：**依赖只能从外向内（Dependency Rule）**。

- **Presentation（表现层）**：Vue 组件/页面、路由、UI 状态（Store）。
- **Domain（领域层）**：实体、值对象、领域服务、领域错误、用例（Use Case）、仓储接口（Repository Port）。
- **Data（数据层）**：DTO、Mapper、Repository 实现、Remote/Local DataSource（对接外部系统）。
- **Infrastructure（基础设施层）**：HTTP 客户端、缓存/Storage、监控、通用工具等（跨 feature 复用）。

允许依赖方向：
- Presentation → Domain
- Data → Domain
- Infrastructure → (Data/Domain) 只能通过内层定义的接口（Ports）与类型进行交互

## 3. 推荐目录结构（infrastructure + features）

按你的分层要求：顶层只分 `infrastructure/` 与 `features/`。业务以 feature 作为垂直切片单元（如 `auth`、`home`），每个 feature 下固定为 `data/domain/presentation/mock/test/di`。

```text
src/
  infrastructure/              # 跨 feature 的基础设施（可替换、可测试）
    http/                      # httpClient、拦截器、错误映射
    storage/                   # localStorage/IndexedDB 封装
    logger/                    # 日志/埋点
  features/
    auth/
      domain/                  # Entities/VO/Errors/Ports/UseCases
      data/                    # DTO/Mappers/DataSources/Repo impl（依赖 infrastructure）
      presentation/            # pages/components/stores/routes
      di/                      # 该 feature 的组装与导出（use cases、routes 等）
      mock/                    # mock repo、fixtures、MSW handlers（可选）
      test/                    # 单测（domain/data/presentation 分层写）
    home/
      domain/
      data/
      presentation/
      di/
      mock/
      test/
```

约定：
- **feature 之间禁止直接互相 import**；确需共享，优先沉到 `src/infrastructure/`（通用能力）或抽成独立 feature（如 `features/permission`）。
- **Presentation 禁止直连 HTTP/Storage**（只能经由 Domain 用例 + Data 仓储实现）。

## 4. 关键落地模式

### 4.1 Use Case 驱动（UI 只“调用用例”）

- Presentation（组件/Store）不直接调用 HTTP/Storage。
- Presentation 只调用 Domain 的 Use Case，并处理“Loading/Empty/Error”渲染。

例：`LoginUseCase.execute(input) -> Result<AuthSession>`

### 4.2 Repository Port（接口在内层，实现在外层）

Domain 定义接口（Ports）：
- `AuthRepository`、`UserRepository`、`PermissionRepository` 等

Data 提供实现（可依赖 infrastructure）：
- `HttpAuthRepository`（REST，经由 `infrastructure/http`）
- `LocalAuthRepository`（本地缓存，经由 `infrastructure/storage`）
- `MockAuthRepository`（`features/*/mock`，测试/本地开发）

### 4.3 DTO 映射与运行时校验

后端返回的数据属于外部世界，推荐：
- Infrastructure 层将 `ApiXxxDto` 映射为 Domain 实体/值对象
- 使用运行时校验（如 `zod`）保证边界数据安全（可选但推荐）

### 4.4 错误模型统一（面向业务语义）

建议统一 `Result<T>` 或“异常 + 错误码”策略：
- Domain 错误：业务不可满足（如权限不足、状态不允许）
- Infrastructure 错误：网络/超时/协议/解析失败
- Presentation 只关心“如何展示与交互”（toast、重试、跳转登录）

### 4.5 权限与路由（策略放在 Application）

推荐将权限判定抽成策略（Policy/PermissionService）放在 Application：
- 路由 meta 只声明需求（如 `requiredPermissions`）
- 具体判断交给应用层服务，便于测试与复用

## 5. 组合根（Composition Root）与依赖注入

建议把组装分两层：
- **全局基础设施组装**：在入口（如 `src/main.ts` 旁）创建 `httpClient/storage/logger` 等（`src/infrastructure/*`）。
- **Feature 组装**：每个 feature 的 `di/` 负责把 `domain` 的 ports 与 `data` 的实现拼起来，并导出给 presentation 使用。

示例（约定）：
- `features/auth/di/index.ts`：导出 `makeAuthUseCases(deps)`、`authRoutes`、（可选）`authStores`

原则：**只有组合根允许同时 import “presentation 与 infrastructure”**。

## 6. 工程化与约束（保证架构不被破坏）

**建议的约束手段**
- TS path alias：`@/infrastructure`, `@/features`，减少相对路径并强化边界。
- ESLint 规则（如 `import/no-restricted-paths`）：
  - 禁止 `features/*/presentation` import `features/*/data` 或 `infrastructure/http`（只能依赖本 feature 的 `domain/di` 导出）
  - 禁止跨 feature 直接 import（除非明确允许的公共入口）
- 统一命名：
  - 用例：`XxxUseCase`
  - 仓储接口：`XxxRepository`
  - HTTP 实现：`HttpXxxRepository`
  - DTO：`XxxDto` / `ApiXxxDto`

**建议的测试策略**
- Domain/Application：Vitest 单测（纯函数/纯 TS，最快最稳）
- Infrastructure：用 MSW 做 API 交互测试（可选）
- E2E：Playwright（可选，用于登录/权限/表单流程）

## 7. 建设路线（从 0 到可迭代）

1) **建立骨架**：`infrastructure/` + `features/`，并确定 feature 的 `data/domain/presentation/mock/test/di` 约定  
2) **先做一个垂直切片**：建议从 `features/auth`（登录、token、权限、路由守卫）开始  
3) **沉淀 infrastructure**：httpClient、错误映射、storage、logger、请求重试等  
4) **加约束与测试**：eslint 边界规则 + vitest 基础覆盖  
5) **持续演进**：把“变化最快的”留在外层（UI/HTTP），把“最稳定的”沉到内层（Domain/Use Case）

## 8. 推荐依赖（可按阶段引入）

- 路由：`vue-router`
- 状态：`pinia`
- HTTP：`axios`（或封装 `fetch`）
- 运行时校验：`zod`
- 测试：`vitest`、`@testing-library/vue`（可选）

